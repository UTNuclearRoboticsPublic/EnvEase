#! /usr/bin/python3
############################################################################################
#      Copyright : CopyrightÂ© The University of Texas at Austin, 2022. All rights reserved.
#                
#          All files within this directory are subject to the following, unless an alternative
#          license is explicitly included within the text of each file.
#
#          This software and documentation constitute an unpublished work
#          and contain valuable trade secrets and proprietary information
#          belonging to the University. None of the foregoing material may be
#          copied or duplicated or disclosed without the express, written
#          permission of the University. THE UNIVERSITY EXPRESSLY DISCLAIMS ANY
#          AND ALL WARRANTIES CONCERNING THIS SOFTWARE AND DOCUMENTATION,
#          INCLUDING ANY WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
#          PARTICULAR PURPOSE, AND WARRANTIES OF PERFORMANCE, AND ANY WARRANTY
#          THAT MIGHT OTHERWISE ARISE FROM COURSE OF DEALING OR USAGE OF TRADE.
#          NO WARRANTY IS EITHER EXPRESS OR IMPLIED WITH RESPECT TO THE USE OF
#          THE SOFTWARE OR DOCUMENTATION. Under no circumstances shall the
#          University be liable for incidental, special, indirect, direct or
#          consequential damages or loss of profits, interruption of business,
#          or related expenses which may arise from use of software or documentation,
#          including but not limited to those resulting from defects in software
#          and/or documentation, or loss or inaccuracy of data of any kind.
#
############################################################################################

import argparse
import argcomplete
from argcomplete.completers import ChoicesCompleter

import os
from pathlib import Path
import shutil
import subprocess
import sys
from typing import List



class NrgEnv():

  def __init__(self):
    self.env_dir = Path.home() / '.nrg_env'
    self.configs_dir = self.env_dir / 'configs'

    self.nullary_commands = {'list', 'show', 'clear'}
    self.unary_commands = {'add', 'rm', 'modify', 'set'}
    self.binary_commands = {'cp'}

  def create_parser(self) -> argparse.ArgumentParser:
    """ Parses the command line args. """
    parser = argparse.ArgumentParser(description="Manages NRG environment configurations.")
    parser.add_argument('command', type=str,
                        choices=('add', 'cp', 'rm', 'modify', 'clear', 'list', 'show', 'set'),
                        help='The action to take.')
    parser.add_argument('target', type=str, nargs='?', default='',
                        help="The name of the environment configuration to act on."
                             " Not used with nullary commands.").completer = self.configs_completer
    parser.add_argument('dest', type=str, nargs='?', default='',
                        help="The destination configuration name. Only used for binary commands").completer = self.configs_completer

    return parser

  def configs_completer(self, prefix: str, parsed_args, **kwargs) -> List[str]:
    if parsed_args.command in self.nullary_commands:
      return []

    if parsed_args.command in self.unary_commands:
      if parsed_args.target != '':
        return []

    matches = self.configs_dir.glob(prefix + '*.sh')

    return [file.stem for file in matches]

  def add(self, target: str, _) -> int:
    src = Path('/opt/nuclearrobotics/config_template.sh')
    dest = self.configs_dir / (target + '.sh')

    if not src.exists():
      print('Error: Configuration template file is missing from expected location /opt/nuclearrobotics')
      return 10

    if dest.exists():
      print('Error: Configuration {} already exists.'.format(target))
      return 10

    try:
      shutil.copyfile(src, str(dest))
    except:
      print('Error: Failed to copy new configuration file from template.')
      return 10

    return self.modify(target)

  def cp(self, target: str, dest: str) -> int:
    src = self.configs_dir / (target + '.sh')
    dest = self.configs_dir / (dest + '.sh')

    if src == dest:
      print('Error: Source and destination configuration names are the same.'.format(target))
      return 10

    if not src.exists():
      print('Error: Configuration {} does not exist.'.format(target))
      return 10

    try:
      shutil.copyfile(str(src), str(dest))
    except:
      print('Error: Failed to copy configuration file.')
      return 10

    return 0

  def rm(self, target: str, _) -> int:
    dest = self.configs_dir / (target + '.sh')

    if not dest.exists():
      print('Error: Configuration {} does not exist.'.format(target))
      return 10
    
    try:
      dest.unlink()
    except:
      print('Error: Failed to remove configuration file.')
      return 10

    return 0

  def modify(self, target: str, _) -> int:
    dest = self.configs_dir / (target + '.sh')

    if not dest.exists():
      print('Error: Configuration {} does not exist.'.format(target))
      return 10

    try:
      subprocess.run(['xdg-open', str(dest)], check=True)
    except subprocess.CalledProcessError as err:
      print('Error: Default text editor exited with code ' + str(err.returncode))
      return 10
    except:
      print('Error: Failed to open default text editor.')
      return 10

    return 0

  def list(self, *_) -> int:
    p = self.configs_dir.glob('**/*')
    config_files = [x for x in p if x.is_file() and x.suffix == '.sh']

    for f in config_files:
      print(f.stem)

    if not config_files:
      print('No configurations')

    return 0

  def show(self, *_) -> int:

    if 'NRG_ENV' in os.environ and os.environ['NRG_ENV'] != 'none':
      print(os.environ['NRG_ENV'])
    else:
      print('No environment currently set.')

    return 0

  def clear(self, *_) -> int:
    
    # iterate over files in configs directory
    config_files = Path(self.configs_dir).glob('*')
    for file in config_files:
      self.rm(file.stem, None)

    self.set('none', None)

    return 0

  def set(self, target: str, _) -> int:
    config_file = self.configs_dir / (target + '.sh')

    if not config_file.exists() and target != 'none':
      print('Error: Configuration {} does not exist.'.format(target))
      return 10

    dest = self.env_dir / 'cur_env.sh'

    try:
      with open(dest,'w') as f:
        f.write("export NRG_ENV=")
        f.write(target)
        f.write('\n')
    except OSError as err:
      print('Failed to edit cur_env.sh. ' + err.strerror)
      return 10

    print('Configuration set. Be sure to source your bashrc file.')

    return 0

  def main(self, args):
    # parse arguments
    parser = self.create_parser()
    argcomplete.autocomplete(parser)
    parsed_args = parser.parse_args(args[1:])

    if parsed_args.command in self.nullary_commands:
      if parsed_args.target != '':
        print("Error: argument 'target' is not used with this command")
        parser.print_help()
        return 2
    elif parsed_args.command in self.unary_commands:
      if parsed_args.target == '':
        print("Error: argument 'target' is required for this command")
        parser.print_help()
        return 3
    elif parsed_args.command in self.binary_commands:
      if parsed_args.target == '' or parsed_args.dest == '':
        print("Error: arguments 'target' and 'dest' are required for this command")
        parser.print_help()
        return 4
    else:
      print('Error: Unrecognized command ' + parsed_args.command)
      parser.print_help()
      return 1
    
    # use dispatch pattern to invoke method with same name
    return getattr(self, parsed_args.command)(parsed_args.target, parsed_args.dest)

if __name__ == '__main__':
  result = NrgEnv().main(sys.argv)
  exit(result)